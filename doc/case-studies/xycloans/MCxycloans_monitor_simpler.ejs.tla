------------------------------- MODULE MC -------------------------------
<%#
/*
 * An EJS template for generating the initial state from the aggregated
 * state of the contract.
 *
 * Usage:
 *
 * npx ejs MCxycloans_monitor_simpler.ejs.tla -f state.json >MC.tla
 *
 * Igor Konnov, 2024
 */
%>
(* THIS MODULE IS AUTOGENERATED FROM SOROBAN STATE *)
EXTENDS Integers, Apalache, xycloans_types

\* the set of all possible token amounts
AMOUNTS == Nat
\* the contract address for the xycLoans contract
XYCLOANS == "<%- contractId %>"
\* the token address
XLM_TOKEN_SAC_TESTNET == "<%- storage[contractId].instance.TokenId %>"

<%
const balanceAddrs =
    Object.keys(storage[contractId].persistent)
        .filter((key) => key.startsWith("Balance,"))
        .map((key) => key.split(",")[1])
%>
\* user-controlled addresses
USER_ADDR == {
<%-
    balanceAddrs
        .map((addr) => `    "${addr}"`)
        .join(",\n")
%>
}

<%
const tokenAddrs =
    Object.keys(storage[storage[contractId].instance.TokenId].persistent)
        .filter((key) => key.startsWith("Balance,"))
        .filter((key) => key !== `Balance,${contractId}`)
        .map((key) => key.split(",")[1])
%>
\* addresses that hold token balances
TOKEN_ADDR == {
<%-
    tokenAddrs
        .map((addr) => `    "${addr}"`)
        .join(",\n")
%>
}

\* the pool of addresses to draw the values from
ADDR == { XYCLOANS, XLM_TOKEN_SAC_TESTNET } \union TOKEN_ADDR \union USER_ADDR

VARIABLES
    \* @type: $tx;
    last_tx,
    \* Keep track of the current storage,
    \* which can be only changed by a successful transaction.
    \* @type: $storage;
    storage

INSTANCE xycloans_monitor_simpler

<%
function renderKVStore(storage, prefix, mapper = (x) => x) {
    return Object.keys(storage)
        .filter((key) => key.startsWith(prefix))
        .map((key) => key.split(",")[1])
        .map((addr) => `    <<"${addr}", ${mapper(storage[prefix + addr])}>>`)
        .join(",\n")
}
%>

Init ==
    LET init_stor == [
        self_instance |-> [
            FeePerShareUniversal |-> <%- storage[contractId].instance.FeePerShareUniversal %>,
            TokenId |-> "<%- storage[contractId].instance.TokenId %>"
        ],
        self_persistent |-> [
            Balance |-> SetAsFun({
<%-
        renderKVStore(storage[contractId].persistent, "Balance,")
%>
            }),
            MaturedFeesParticular |-> SetAsFun({
<%-
        renderKVStore(storage[contractId].persistent, "MaturedFeesParticular,")
%>
            }),
            FeePerShareParticular |-> SetAsFun({
<%-
        renderKVStore(storage[contractId].persistent, "FeePerShareParticular,")
%>
            })
        ],
        token_persistent |-> [ Balance |-> SetAsFun({
<%-
        renderKVStore(storage[storage[contractId].instance.TokenId].persistent, "Balance,", (x) => x.amount)
%>
        })]
    ]
    IN
    \* initialize the contract state that we model
    /\ last_tx = [
            call |-> Constructor(XYCLOANS),
            status |-> TRUE,
            env |-> [
                current_contract_address |-> XYCLOANS,
                storage |-> init_stor,
                old_storage |-> init_stor
            ]
        ]
    /\ storage = init_stor

Next ==
    \* Generate some values for the storage.
    \* For value generation, we go over all addresses, not subsets of addresses.
    \E fpsu \in AMOUNTS, tid \in { "", XLM_TOKEN_SAC_TESTNET }:
      \E b, mfp, fpsp, tb \in [ ADDR -> AMOUNTS ]:
        LET new_stor == [
                self_instance |-> [ FeePerShareUniversal |-> fpsu, TokenId |-> tid ],
                self_persistent |->
                    [ Balance |-> b, MaturedFeesParticular |-> mfp, FeePerShareParticular |-> fpsp ],
                token_persistent |-> [ Balance |-> tb ]
            ]
            env == [
                current_contract_address |-> XYCLOANS,
                storage |-> new_stor,
                old_storage |-> storage
            ]
        IN
        \E addr \in USER_ADDR, amount \in AMOUNTS, success \in BOOLEAN:
            /\  \/ LET tx == [ env |-> env, call |-> Initialize(XLM_TOKEN_SAC_TESTNET), status |-> success ] IN
                   initialize(tx) /\ last_tx' = tx
                \/ LET tx == [ env |-> env, call |-> Deposit(addr, amount), status |-> success ] IN
                   deposit(tx) /\ last_tx' = tx
                \/ LET tx == [ env |-> env, call |-> Borrow(addr, amount), status |-> success ] IN
                   borrow(tx) /\ last_tx' = tx
                \/ LET tx == [ env |-> env, call |-> UpdateFeeRewards(addr), status |-> success ] IN
                   update_fee_rewards(tx) /\ last_tx' = tx
                \/ LET tx == [ env |-> env, call |-> WithdrawMatured(addr), status |-> success ] IN
                   withdraw_matured(tx) /\ last_tx' = tx
                \/ LET tx == [ env |-> env, call |-> Withdraw(addr, amount), status |-> success ] IN
                   withdraw(tx) /\ last_tx' = tx
            /\ storage' = IF success THEN new_stor ELSE storage

\* restrict the executions to the successful transactions
NextOk ==
    Next /\ last_tx'.status

\* a core invariant that should be always satisfied
SolvencyInv ==
    \* NOTE: we can use TotSupply of the contract storage, if we add it to the storage definitions
    LET Add(sum, addr) == sum + storage.self_persistent.Balance[addr]
        totSupply == ApaFoldSet(Add, 0, DOMAIN storage.self_persistent.Balance)
    IN
    totSupply <= get_or_else(storage.token_persistent.Balance, XYCLOANS, 0)

\* use this falsy invariant to generate examples of successful transactions
NoSuccessInv ==
    ~IsConstructor(last_tx.call) => ~last_tx.status

\* use this invariant to generate transactions that are both successful and lead to insolvency
NoSuccessOrSolventInv ==
    NoSuccessInv \/ SolvencyInv

\* use this view to generate better test coverage
\* apalache-mc check --max-error=10 --length=10 --inv=NoSuccessInv --view=View MCxycloans_monitor.tla
View == <<last_tx.status, VariantTag(last_tx.call)>>
=========================================================================================